# Story 3.3: Connect Watchlist Page to tRPC API

## Status
Approved

## Story
**As an** Authenticated User,
**I want** my watchlist page to display my saved stocks from the database,
**so that** my list is always up-to-date.

## Acceptance Criteria
1. The watchlist page calls the `getWatchlist` tRPC endpoint on load.
2. The list of stocks returned from the API is displayed on the page.
3. A loading state is shown while the data is being fetched.
4. An empty state is shown if the user's watchlist is empty.
5. Clicking the "Remove" button calls the `removeFromWatchlist` endpoint and updates the UI.

## Tasks / Subtasks
- [ ] Integrate tRPC getWatchlist query with WatchlistContent component (AC: 1, 2)
  - [ ] Replace mock data in `apps/web/src/components/ui/watchlist-content.tsx` with `api.watchlist.get.useQuery()`
  - [ ] Ensure proper authentication context is passed through component hierarchy
  - [ ] Handle query state transitions (loading, error, success) in component logic
  - [ ] Map WatchlistItem database objects to component props structure
- [ ] Implement real stock data fetching for watchlist items (AC: 2)
  - [ ] For each watchlist symbol, fetch current stock quote using `api.stock.getGlobalQuote.useQuery()`
  - [ ] Consider batching strategy or parallel queries for multiple symbols
  - [ ] Display real-time stock prices, changes, and percentage changes
  - [ ] Handle cases where stock data fetching fails for individual symbols
- [ ] Connect remove functionality to tRPC mutation (AC: 5)
  - [ ] Replace placeholder remove handler in WatchlistItem with `api.watchlist.remove.useMutation()`
  - [ ] Implement optimistic UI updates for immediate user feedback
  - [ ] Handle mutation errors and provide user feedback
  - [ ] Ensure UI reverts on mutation failure
- [ ] Verify and enhance loading/error states (AC: 3, 4)
  - [ ] Ensure loading skeleton in WatchlistContent matches actual content layout
  - [ ] Verify empty state displays correctly when API returns empty array
  - [ ] Add retry mechanism for failed watchlist queries
  - [ ] Test error boundaries for catastrophic API failures
- [ ] Add comprehensive integration tests
  - [ ] Test component with real tRPC endpoint mocking
  - [ ] Mock successful and failed API responses
  - [ ] Verify optimistic updates and error recovery behavior
  - [ ] Test concurrent stock data fetching scenarios

## Dev Notes

### Previous Story Insights
From Story 3.2 implementation:
- WatchlistContent component structure already established with proper loading/empty/error states
- WatchlistItem component implemented with remove button placeholder functionality
- Authentication patterns working correctly with protected route structure
- DaisyUI styling patterns established and working well
- Testing infrastructure (51 tests) provides solid foundation for integration testing
- Component separation between Server (page) and Client (content, items) boundaries optimized

### Data Models
[Source: architecture/5-data-models-database-schema.md]
**WatchlistItem Model:**
```typescript
model WatchlistItem {
  id        Int      @id @default(autoincrement())
  symbol    String
  createdAt DateTime @default(now())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@unique([userId, symbol])
}
```
- Query returns array of `WatchlistItem` objects with `symbol` field for stock data fetching
- `createdAt` field available for sorting by recently added items
- Unique constraint on `userId_symbol` prevents duplicate entries

### API Specifications
[Source: architecture/6-api-specification-trpc.md]
**Watchlist Router Endpoints:**
```typescript
export const watchlistRouter = createTRPCRouter({
  get: protectedProcedure.query(({ ctx }) => {
    return ctx.prisma.watchlistItem.findMany({
      where: { userId: ctx.session.user.id },
    });
  }),
  remove: protectedProcedure
    .input(z.object({ symbol: z.string() }))
    .mutation(async ({ ctx, input }) => {
      // Logic to remove a symbol
    }),
});
```

**Stock Router Endpoints for Real-Time Data:**
```typescript
export const stockRouter = createTRPCRouter({
  getGlobalQuote: publicProcedure
    .input(z.object({ symbol: z.string().min(1).max(10) }))
    .query(async ({ input }) => {
      // Returns: StockQuoteData with price, change, OHLC, volume
    }),
});
```

### Component Specifications
[Source: architecture/frontend-architecture.md]
**Existing Component Structure (from Story 3.2):**
- **WatchlistContent**: Client component handling data fetching and state management
- **WatchlistItem**: Client component for individual stock display with interactivity
- **WatchlistPage**: Server component with authentication protection

**Integration Requirements:**
- Replace mock data with tRPC queries in WatchlistContent component
- Maintain existing loading/empty/error state patterns
- Preserve DaisyUI styling and responsive design
- Keep optimistic UI update patterns for remove functionality

### File Locations
[Source: architecture/4-monorepo-project-structure.md]
**Files to Modify:**
- `apps/web/src/components/ui/watchlist-content.tsx` - Replace mock data with tRPC query
- `apps/web/src/components/ui/watchlist-item.tsx` - Connect remove button to mutation
- `apps/web/src/components/ui/__tests__/watchlist-content.test.tsx` - Update tests for API integration
- `apps/web/src/components/ui/__tests__/watchlist-item.test.tsx` - Update tests for remove mutation

### Technical Constraints
[Source: architecture/10-coding-standards-for-ai-agents.md]
- **Type Safety**: All tRPC query/mutation results must have explicit TypeScript types
- **tRPC Integration**: Use only tRPC hooks for API calls (`api.watchlist.get.useQuery`, `api.watchlist.remove.useMutation`)
- **Error Handling**: All tRPC procedures must include structured error handling with specific error codes
- **Client Components**: Only components using tRPC hooks need `'use client'` directive
- **Optimistic Updates**: Use React Query's optimistic update patterns for immediate UI feedback

**Tech Stack Requirements:**
[Source: architecture/3-tech-stack.md]
- **API Layer**: tRPC 11.x for end-to-end type safety
- **Client State**: React Query 5.x via tRPC integration for caching and data fetching
- **Database**: Prisma 6.15.x ORM for database operations

### Authentication Requirements
[Source: architecture/7-authentication.md]
- tRPC `protectedProcedure` ensures user authentication is validated server-side
- Client components receive authenticated context through tRPC client setup
- Existing authentication patterns from previous stories should be maintained

### Testing Requirements
[Source: architecture/9-testing-strategy.md]
**Testing Framework**: Vitest with React Testing Library for component integration tests

**Specific Testing Requirements for This Story:**
- Test WatchlistContent component with mocked `api.watchlist.get.useQuery` responses
- Test loading state during API calls
- Test successful data rendering with populated watchlist
- Test empty state when API returns empty array
- Test error state when API calls fail
- Test WatchlistItem remove button with mocked `api.watchlist.remove.useMutation`
- Test optimistic UI updates during remove operations
- Test error recovery when remove mutations fail
- Test concurrent stock data fetching for multiple watchlist items
- Mock all tRPC endpoints consistently across test files

**Test File Updates:**
- Update `apps/web/src/components/ui/__tests__/watchlist-content.test.tsx` to mock tRPC queries
- Update `apps/web/src/components/ui/__tests__/watchlist-item.test.tsx` to mock remove mutations
- Ensure all 51 existing tests continue passing after API integration

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-04 | 1.0 | Initial story creation for tRPC API integration | David Hargitai (dev) |

## Dev Agent Record

### Agent Model Used
*To be filled by development agent*

### Debug Log References
*To be filled by development agent*

### Completion Notes List
*To be filled by development agent*

### File List
*To be filled by development agent*

## QA Results
*To be filled by QA agent*